# Тестовое задание Kotlin Backend — Карточная игра

## API игры

1.**Регистрация и аутентификация**
- `POST /api/auth/register` — регистрация нового пользователя
- `POST /api/auth/login` — аутентификация пользователя и получение JWT

---
## Используемые фреймворки и библиотеки

- **Kotlin (JDK 21)**
- **Ktor, JWT (Auth0)**
- **SQLite, Exposed**
- **Kotlin Test, Mockk, Kotest**
- **Docker**
---
## Запуск

1. Собрать проект `./gradlew clean build`
2. Собрать Docker-образ `docker build -t kokodi-card-game .`
3. Запустить Docker-контейнер `docker run -p 8080:8080 --name kokodi-card-game kokodi-card-game`

## TODO

-

---

## Описание задания

Во вселенной «Кокоди» существует карточная игра, где несколько пользователей собирают очки, разыгрывая специальные карты. Для упрощённого прототипа выделим следующие элементы.

### Игрок (User)
- У каждого игрока есть уникальный `id`, `name`.
- Игрок может участвовать в нескольких партиях, но внутри одной партии он участвует только один раз.

### Партия (Game Session)
- Имеет уникальный `id`.
- Может содержать от 2 до 4 игроков (включительно).
- Имеет состояние (например, `waitForPlayers`, `inProgress`, `finished`).
- Хранит колоду `deck` специальных карт.
- Хранит историю ходов `turns` для отладки/аналитики.

### Карты (Cards)
- Бывают двух типов:
  - **Points Card** — При розыгрыше даёт игроку X очков.
  - **Action Card** — Оказывает эффект на других игроков (например, заставляет пропустить ход или отнять у игрока X очков).
- У каждой карты есть уникальное название `name` и числовой параметр `value`, используемый по-разному в зависимости от типа карты.

### Ход (Turn)
- В каждый ход активный игрок берёт верхнюю карту колоды.
- Если это `Points Card`, игроку добавляются очки, равные `value`.
- Если это `Action Card` — нужно применить уникальный эффект (см. раздел "Правила для Action Card" ниже).
- После применения эффекта карта сбрасывается (т. е. из колоды удаляется).
- В конце хода проверяется, не достиг ли игрок лимита в 30 очков (или любой другой заданной константы) — если да, игра завершается.

## Правила для `Action Card`

- **Block (`value` = 1)**: следующий игрок пропускает ход (в логике нужно предусмотреть, как это отразится на порядке ходов).
- **Steal (`value` = N)**: активный игрок отнимает у выбранного соперника N очков (не позволяя при этом уходить в минус: минимум 0).
- **DoubleDown (`value` = 2)**: активный игрок удваивает свою текущую сумму очков, но не более чем до 30.

## Задача

Нужно написать микросервис на Kotlin (любой фреймворк на выбор), который реализует регистрацию игроков, управление партиями и логику ходов.

### Регистрация и авторизация
- Endpoint для создания пользователя (`login`, `password`, `name`).
- SQLite/PostgreSQL или in-memory хранилище.
- При первом знакомстве с системой пользователь регистрируется, при повторном — авторизуется (предпочтительно JWT).

### Управление партиями
- Endpoint для создания новой партии. Создатель становится первым игроком.
- Endpoint для присоединения к партии по её `id`, если в ней меньше 4 игроков.
- Endpoint/метод для старта партии (если игроков хотя бы 2).
- При старте генерируется/заполняется колода: придумайте от 5 до 10 уникальных карт (карты должны включать оба типа "points" и "actions"). Порядок колоды случайный.

### Ходы
- `POST /games/{gameId}/turn`:
  - Проверка очереди хода.
  - Вытягивание карты и применение эффекта.
  - Обработка `Action Cards`.
  - Записывать ход (какая карта, на кого эффект, сколько очков теперь у игрока и т.п.).
  - Проверять условие завершения игры (если у кого-то стало >= 30 очков).
  - Если игра завершена, вызов этого эндпоинта должен возвращать ошибку или сообщение "Game is finished".

### Получение статуса игры
- Endpoint, возвращающий текущее состояние партии: список игроков с их очками, состояние колоды (сколько карт осталось), статус (в процессе / завершена), кто ходит следующим и т.п.

### Тесты
- Хотя бы пара тестов (юнит или интеграционные) на:
  - Создание партии и присоединение игроков.
  - Пример "хода", где разыгрывается `Action Card`, и проверяется, что очки действительно убыли/увеличились как надо.

## Требования к проекту

- Код на Kotlin.
- Сервер (можно Ktor, Spring Boot, Micronaut — на выбор).
- Минимум зависимостей. Можно использовать любую библиотеку для JSON-сериализации.
- Docker-файл или инструкция, как запустить.
- Краткая документация (README.md) — какие endpoint'ы есть и для чего.
